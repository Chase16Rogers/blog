(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{485:function(e,t,a){"use strict";a.r(t);var i=a(2),n=Object(i.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"day-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#day-2"}},[e._v("#")]),e._v(" Day 2")]),e._v(" "),a("p",[a("strong",[e._v("02/23/21")])]),e._v(" "),a("h2",{attrs:{id:"what-is-the-difference-between-a-primary-key-and-a-foreign-key"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#what-is-the-difference-between-a-primary-key-and-a-foreign-key"}},[e._v("#")]),e._v(" What is the difference between a primary key and a foreign key?")]),e._v(" "),a("p",[e._v("A primary key is the key by which the data in the table will most commonly be referenced. This is typically the id of that item as it is a convenient unique property to search by. The foreign key is similar, in that it defines a value by which to search forn the children of a parent that have been given an id in order to define a relationship between the two data sets. The foreign key essentially takes the place of virtuals in Mongoose/Mongodb.")]),e._v(" "),a("h2",{attrs:{id:"what-is-an-alias"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#what-is-an-alias"}},[e._v("#")]),e._v(" What is an Alias?")]),e._v(" "),a("p",[e._v("An alias is a second name that can be given to a binding. Typically much shorter than the actual name, like a single character. This can make it much faster/easier to write as you would only need a single character to reference the binding instead of writing out it's entire name. If done right it's supposed to even maintain readability, but at a glance it seems like the opposite. While it is reasonable to understand a single character references this conceptual list, quickly reading and trying to understand the code all of the single characters make it more convoluted, at least in my opinion.")]),e._v(" "),a("h2",{attrs:{id:"writing-a-join-statement-to-get-all-the-patients-for-a-doctor"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#writing-a-join-statement-to-get-all-the-patients-for-a-doctor"}},[e._v("#")]),e._v(" Writing a join statement to get all the patients for a doctor.")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('internal IEnumerable<Patient> GetPatientsByDoctor(int id)\n{\nstring sql = @"\nSELECT p.*,\nmd.id as PatDocId\nFROM doctors md\nJOIN patients p ON p.id = md.patientId\nWHERE doctorId = @id;";\nreturn _db.Query<DoctorPatientViewModel>(sql, new { id });\n}\n')])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br")])]),a("ul",[a("li",[e._v("So it all starts with simply declaring the method, output type, and parameters.")]),e._v(" "),a("li",[e._v("Then because we use dapper to sanitize our entries, it is more readable to bind the actual request before injecting.")]),e._v(" "),a("li",[e._v("My logical understanding starts with the FROM statement, here we reference the table that holds the relationship.")]),e._v(" "),a("li",[e._v("It then bounces down to the WHERE that specifies which collection is making the request.\n"),a("ul",[a("li",[e._v("We have a doctor, and we want their patients, so we give it the doctor id, and pull all the relationships related to that particular doctor.")])])]),e._v(" "),a("li",[e._v("Next we hit the JOIN statement. This goes to the patients table and pulls every patient who's Id is in the same relationship with the doctor's id.\n"),a("ul",[a("li",[e._v("It's here where it also references the SELECT line, that's what tells it to find every patient.")]),e._v(" "),a("li",[e._v("This is also what gives us the information by somehow appending the information it recieves to the relationship table that it gives us.")])])]),e._v(" "),a("li",[e._v("Finally (for the injection) we attatch the relationship id to a child class of the original model who's only job is holding this property.")]),e._v(" "),a("li",[e._v("Last but not least we make the dapper query, we tell it to give us the child class I mentioned before, and give it the string we just made and the doctor's id so it can actually make the request.")])]),e._v(" "),a("h2",{attrs:{id:"afternoon-challenge"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#afternoon-challenge"}},[e._v("#")]),e._v(" Afternoon Challenge")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/Chase16Rogers/contract-jobs",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/Chase16Rogers/contract-jobs"),a("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=n.exports}}]);